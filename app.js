// Generated by CoffeeScript 1.7.1
(function() {
  var Foo, autocomplete, dir, evaluate, getPropertys, help, include, macroexpand, space, suggest;

  $(function() {
    var $_, $form, $input, $log, history;
    $log = $("#log");
    $form = $("#console");
    $input = $("#console-input");
    setTimeout((function() {
      $input.focus();
      return $form.submit();
    }), 100);
    history = [];
    $_ = null;
    return $form.submit(function(ev) {
      var ary, buffer, clear, err, input, log, n, output, pre, _ref;
      input = $input.val();
      history.unshift(input);
      if (n = (/\.(\d+)$/.exec(input) || [false, false])[1]) {
        $input.val(history[n]);
      } else if (/\s$/.test(input)) {
        _ref = autocomplete(input), pre = _ref[0], ary = _ref[1];
        if (ary.length === 0) {

        } else if (ary.length === 1) {
          $input.val((pre + " " + ary[0]).replace(/^\s+/, ""));
        } else {
          $input.val(input.replace(/\s+$/, ""));
          $log.append("coffee> " + input + "\n");
          $log.append("" + (ary.join("\n")) + "\n");
          $(window).scrollTop(9999999);
        }
      } else {
        if (/\.help$/.test(input)) {
          output = help;
        } else {
          buffer = "";
          log = function(str) {
            buffer += str + "\n";
            return void 0;
          };
          clear = function() {
            $log.html("");
            return void 0;
          };
          try {
            output = evaluate(macroexpand(input), {
              log: log,
              clear: clear,
              $_: $_
            });
          } catch (_error) {
            err = _error;
            output = buffer + err + "\n" + err.stack;
          }
        }
        $_ = output;
        $input.val("");
        $log.append("coffee> " + input + "\n");
        $log.append(output + "\n");
        $log.append("\n");
      }
      setTimeout((function() {
        $(window).scrollTop(9999999);
        return $input.focus();
      }), 100);
      return false;
    });
  });

  help = ".help  show repl options\n.1     last input\n.n     nth input\n\nconso[space][enter]\nconsole.lo[space][enter]\n       autocomplete\nconsole.[space][enter]\n       autosuggestion\n\nlog(str)     alter console.log()\nclear()      alter console.clear()\ndir(obj [, depth])\n             alter console.dir()\ntype(obj)    alter typeof()\ninclude(url) include js file\n$_           last output value";

  include = function(url, next) {
    var script;
    script = document.createElement("script");
    script.src = url;
    script.onload = next;
    document.body.appendChild(script);
    return void 0;
  };

  macroexpand = function(code) {
    return CoffeeScript.compile(code, {
      bare: true
    }).replace(/var[^\;]+;\n\n/, "");
  };

  console.assert(macroexpand("do -> x") === "(function() {\n  return x;\n})();\n", "macroexpand");

  evaluate = function(code, env) {
    if (env == null) {
      env = this;
    }
    var result;
  with(env){
    result = eval(code);
  };
    return result;
  };

  console.assert(evaluate("window") === window, "evaluate");

  getPropertys = function(o) {
    var ary, key, tmp, _ary;
    if (o == null) {
      return [];
    }
    ary = [].concat(Object.getOwnPropertyNames(o), (function() {
      var _results;
      _results = [];
      for (key in o) {
        _results.push(key);
      }
      return _results;
    })());
    tmp = {};
    _ary = ary.filter(function(key) {
      if (tmp[key] != null) {
        return false;
      } else {
        return tmp[key] = true;
      }
    });
    return _ary.sort();
  };

  console.assert("" + getPropertys({
    a: 0
  }) === "" + getPropertys(Object.create({
    a: 0
  })), "getPropertys");

  suggest = function(code, token) {
    var err, reg, result;
    reg = new RegExp("^" + token + ".*");
    try {
      result = evaluate("(" + code + ")");
    } catch (_error) {
      err = _error;
      result = {};
    }
    return getPropertys(result).filter(function(key) {
      return reg.test(key);
    });
  };

  console.assert(suggest("window", "conso")[0] === "console", "suggest conso");

  console.assert(suggest("console", "lo")[0] === "log", "suggest console.lo");

  console.assert(suggest("Math", "p")[0] === "pow", "suggest Math.p");

  autocomplete = function(code) {
    var ary, key, obj, pre, result, token, tokens;
    tokens = (code + " ").split(/\s+/).slice(0, -1);
    token = tokens.pop();
    pre = tokens.join(" ");
    if (token.indexOf(".") === -1) {
      result = suggest("window", token).map(function(str) {
        return str.replace(/\s+$/, "");
      });
    } else {
      ary = token.split(".");
      obj = ary.slice(0, -1).join(".");
      key = ary[ary.length - 1];
      result = suggest(obj, key).map(function(str) {
        return obj + "." + str.replace(/\s+$/, "");
      });
    }
    return [pre, result];
  };

  console.assert(autocomplete("conso")[0] === "" && autocomplete("conso")[1][0] === "console", "autocomplete conso");

  console.assert(autocomplete("console.lo")[0] === "" && autocomplete("console.lo")[1][0] === "console.log", "autocomplete console.lo");

  console.assert(autocomplete("if {a:0}.")[0] === "if", autocomplete("if {a:0}.")[1][0] === "{a:0}.a", "autocomplete {a:0}.");


  /*
  type = (o)->
    if      o is null              then "null"
    else if o is undefined         then "undefined"
    else if o is window            then "global"
    else if o.nodeType?            then "node"
    else if typeof o isnt "object" then typeof o
    else
      _type = Object.prototype.toString.call(o)
      if _type is "[object Object]"
        _type = ""+o.constructor
      (/^\[object (\w+)\]$/.exec(_type)   or
            /^\s*function\s+(\w+)/.exec(_type) or
            ["", "object"])[1].toLowerCase()
   */

  function type(mix) { // @arg Mix: search
                        // @ret TypeLowerCaseString:
                        // @help: mm.type
                        // @desc: get type/class name
    var rv, type, global = window;

    rv = mix === null   ? "null"
       : mix === void 0 ? "undefined"
       : mix === global ? "global"
       : mix.nodeType   ? "node"
       //: mix.__CLASS__  ? mix.__CLASS__ // ES Spec: [[Class]] like internal property
       : "";

    if (rv) {
        return rv;
    }
    // typeof primitive -> "number", "string", "boolean"
    type = typeof mix;
    if (type !== "object") {
        return type;
    }

    // Object.prototype.toString.call(Hoge) -> "[object Hoge]"
    // (new Hoge).constructor.name -> "Hoge" (except IE)
    // (new Hoge).constructor + "" -> "[object Hoge]" or "function Hoge()..."

    type = Object.prototype.toString.call(mix);
    if (type === "[object Object]") {
        rv = mix.constructor.name;
        if (!rv) {
            type = mix.constructor + "";
        }
    }
    if (!rv) {
        rv = ( /^\[object (\w+)\]$/.exec(type)   ||
               /^\s*function\s+(\w+)/.exec(type) || ["", ""] )[1];
    }

    if (!rv || rv === "Object") {
        if (mix[/*mm.strict ? "" : */"callee"] ||
            typeof mix.item === "function") {
            return "list"; // Arguments
        }
    }
    /*if (rv in _mm_type_alias_db) {
        return _mm_type_alias_db[rv];
    }*/
    return rv ? rv.toLowerCase() : "object";
};

  console.assert(type(null) === "null", "type null");

  console.assert(type(void 0) === "undefined", "type undefined");

  console.assert(type(true) === "boolean", "type boolean");

  console.assert(type(0) === "number", "type number");

  console.assert(type("string") === "string", "type string");

  console.assert(type(function() {}) === "function", "type function");

  console.assert(type([]) === "array", "type array");

  console.assert(type({}) === "object", "type object");

  console.assert(type(new Date) === "date", "type date");

  console.assert(type(Math) === "math", "type math");

  console.assert(type(/0/) === "regexp", "type regexp");

  console.assert(type(window) === "global", "type global");

  console.assert(type(document.createElement("div")) === "node", "type node");

  console.assert(type(new (Foo = (function() {
    function Foo() {}

    return Foo;

  })())) === "foo", "type foo");

  space = function(i) {
    var _i, _results;
    return (function() {
      _results = [];
      for (var _i = 0; 0 <= i ? _i <= i : _i >= i; 0 <= i ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function() {
      return "";
    }).join("  ");
  };

  console.assert(space(0) === "", "space 0");

  console.assert(space(1) === "  ", "space 1");

  dir = function(o, max, i) {
    var dumpObj, v;
    if (max == null) {
      max = 1;
    }
    if (i == null) {
      i = 0;
    }
    dumpObj = function(o) {
      if (getPropertys(o).length === 0) {
        return "{}";
      } else {
        return "{\n" + ((getPropertys(o).map(function(k) {
          return "" + (space(i + 1)) + k + ": " + (dir(o[k], max, i + 1));
        })).join(",\n")) + "\n" + (space(i)) + "}";
      }
    };
    switch (type(o)) {
      case "null":
      case "undefined":
      case "boolean":
      case "number":
        return "" + o;
      case "string":
        return "\"" + o + "\"";
      case "function":
        return Object.prototype.toString.call(o);
      case "date":
        return JSON.stringify(o);
      case "array":
        if (i < max) {
          return "[" + (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = o.length; _i < _len; _i++) {
              v = o[_i];
              _results.push(dir(v, max, i + 1));
            }
            return _results;
          })()).join(", ")) + "]";
        } else {
          return Object.prototype.toString.call(o);
        }
        break;
      default:
        if (i < max) {
          return dumpObj(o);
        } else {
          return Object.prototype.toString.call(o);
        }
    }
  };

  console.assert(dir({
    a: 0
  }) === dir(Object.create({
    a: 0
  })), "dir");

}).call(this);

//# sourceMappingURL=app.map
